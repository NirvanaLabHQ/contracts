{
  "address": "0xc3A1d8F206c963E2E1B36B2F20B19435173ca37A",
  "abi": [],
  "transactionHash": "0x42c7db0dbbefc5cda582d8073c5f673f566831a4b9b768648877e139515df18c",
  "receipt": {
    "to": null,
    "from": "0xe0B4c9C36f5A5D0Ff3A547FeaBB6BC9Ba65805F2",
    "contractAddress": "0xc3A1d8F206c963E2E1B36B2F20B19435173ca37A",
    "transactionIndex": 6,
    "gasUsed": "644397",
    "logsBloom": "0x000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000080000020000000000000000000000000000000000000000000000000008000000000000000000401000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000040000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000001000000000000000000000000100000",
    "blockHash": "0x53ddf1118a0f692c8b096a62aa5e4e47b00e92a4ff25068a6975457cb0b684d4",
    "transactionHash": "0x42c7db0dbbefc5cda582d8073c5f673f566831a4b9b768648877e139515df18c",
    "logs": [
      {
        "transactionIndex": 6,
        "blockNumber": 32645692,
        "transactionHash": "0x42c7db0dbbefc5cda582d8073c5f673f566831a4b9b768648877e139515df18c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000e0b4c9c36f5a5d0ff3a547feabb6bc9ba65805f2",
          "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000005b9306bb2c50000000000000000000000000000000000000000000000000006b0bbf54602b519000000000000000000000000000000000000000000000e132239841c14ba50cc00000000000000000000000000000000000000000000000006ab02c4da4ff019000000000000000000000000000000000000000000000e13223f3d4c806d15cc",
        "logIndex": 13,
        "blockHash": "0x53ddf1118a0f692c8b096a62aa5e4e47b00e92a4ff25068a6975457cb0b684d4"
      }
    ],
    "blockNumber": 32645692,
    "cumulativeGasUsed": "1465265",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ee5576cd9d1a90bd97dbc48641d096ea",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/lib/SingleRanking.sol\":\"SingleRanking\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363737383236343739343336\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"src/lib/FastArray.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\n// A simple array that supports insert and removal.\\n// The values are assumed to be unique and the library is meant to be lightweight.\\n// So when calling insert or remove, the caller is responsible to know whether a value already exists in the array or not.\\nlibrary FastArray {\\n    struct Data {\\n        mapping(uint256 => uint256) array;\\n        mapping(uint256 => uint256) indexMap;\\n        uint256 length;\\n    }\\n\\n    /**\\n     * @notice please confirm no eq item exist before insert\\n     */\\n    function insert(Data storage _fastArray, uint256 _value) internal {\\n        _fastArray.array[_fastArray.length] = _value;\\n        _fastArray.indexMap[_value] = _fastArray.length;\\n        _fastArray.length += 1;\\n    }\\n\\n    /**\\n     * @dev remove item from array,but not keep rest item sort\\n     * @notice Please confirm array is not empty && item is exist && index not out of bounds\\n     */\\n    function remove(Data storage _fastArray, uint256 _value) internal {\\n        uint256 index = _fastArray.indexMap[_value];\\n\\n        _fastArray.array[index] = _fastArray.array[_fastArray.length - 1];\\n        delete _fastArray.indexMap[_value];\\n        delete _fastArray.array[_fastArray.length - 1];\\n\\n        _fastArray.length -= 1;\\n    }\\n\\n    /**\\n     * @dev remove item and keep rest item in sort\\n     * @notice Please confirm array is not empty && item is exist && index not out of bounds\\n     */\\n    function removeKeepSort(Data storage _fastArray, uint256 _value) internal {\\n        uint256 index = _fastArray.indexMap[_value];\\n\\n        uint256 tempLastItem = _fastArray.array[_fastArray.length - 1];\\n\\n        for (uint256 i = index; i < _fastArray.length - 1; i++) {\\n            _fastArray.indexMap[_fastArray.array[i + 1]] = i;\\n            _fastArray.array[i] = _fastArray.array[i + 1];\\n        }\\n\\n        delete _fastArray.indexMap[tempLastItem];\\n        delete _fastArray.array[_fastArray.length - 1];\\n        _fastArray.length -= 1;\\n    }\\n\\n    /**\\n     * @notice PLease confirm index is not out of bounds\\n     */\\n    function get(\\n        Data storage _fastArray,\\n        uint256 _index\\n    ) public view returns (uint256) {\\n        return _fastArray.array[_index];\\n    }\\n\\n    function length(Data storage _fastArray) public view returns (uint256) {\\n        return _fastArray.length;\\n    }\\n\\n    function contains(\\n        Data storage _fastArray,\\n        uint256 _value\\n    ) public view returns (bool) {\\n        return _fastArray.indexMap[_value] != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x1aafe47d78876fe514a190e95a87f4720f33617712c66cf95ab73c6dc3a19f3d\",\"license\":\"UNLICENSED\"},\"src/lib/RankingRedBlackTree.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// A red-black tree that holds a \\\"count\\\" variable next to the value in the tree.\\n// This library is used to resolve which values should be skipped to respect the _offset when querying from the rank library.\\n// The focal function is \\\"lastByOffset\\\" which starts from the largest value in the tree and traverses backwards to find the\\n// first value that is included in the offset specified and returns it.\\n// The nodes are accessed by a key and other properties can be queried using the key.\\n// This library is a modification of BokkyPooBah's Red-Black Tree Library which has a MIT licence.\\n// Following is the original description and the license:\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's Red-Black Tree Library v1.0-pre-release-a\\n//\\n// A Solidity Red-Black Tree binary search library to store and access a sorted\\n// list of unsigned integer data. The Red-Black algorithm rebalances the binary\\n// search tree, resulting in O(log n) insert, remove and search time (and ~gas)\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsRedBlackTreeLibrary\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2020. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n// Here is the license attached to this library:\\n// ----------------------------------------------------------------------------\\n// MIT License\\n//\\n// Copyright (c) 2018 The Officious BokkyPooBah\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n// ----------------------------------------------------------------------------\\nlibrary RankingRedBlackTree {\\n    struct Node {\\n        uint id;\\n        uint value;\\n        uint count;\\n        uint parent;\\n        uint left;\\n        uint right;\\n        bool red;\\n    }\\n\\n    struct Tree {\\n        uint root;\\n        mapping(uint => Node) nodes;\\n        uint counter;\\n    }\\n\\n    uint private constant EMPTY = 0;\\n\\n    function first(Tree storage self) public view returns (uint _key) {\\n        _key = self.root;\\n        if (_key != EMPTY) {\\n            while (self.nodes[_key].left != EMPTY) {\\n                _key = self.nodes[_key].left;\\n            }\\n        }\\n    }\\n\\n    function last(Tree storage self) public view returns (uint _key) {\\n        _key = self.root;\\n        if (_key != EMPTY) {\\n            while (self.nodes[_key].right != EMPTY) {\\n                _key = self.nodes[_key].right;\\n            }\\n        }\\n    }\\n\\n    function lastByOffset(\\n        Tree storage self,\\n        uint _offset\\n    ) public view returns (uint, uint) {\\n        uint key = last(self);\\n\\n        while (key != EMPTY && _offset > self.nodes[key].count) {\\n            _offset -= self.nodes[key].count;\\n            key = prev(self, key);\\n        }\\n\\n        return (key, _offset);\\n    }\\n\\n    function next(\\n        Tree storage self,\\n        uint target\\n    ) public view returns (uint cursor) {\\n        require(target != EMPTY);\\n        if (self.nodes[target].right != EMPTY) {\\n            cursor = treeMinimum(self, self.nodes[target].right);\\n        } else {\\n            cursor = self.nodes[target].parent;\\n            while (cursor != EMPTY && target == self.nodes[cursor].right) {\\n                target = cursor;\\n                cursor = self.nodes[cursor].parent;\\n            }\\n        }\\n    }\\n\\n    function prev(\\n        Tree storage self,\\n        uint target\\n    ) public view returns (uint cursor) {\\n        require(target != EMPTY);\\n        if (self.nodes[target].left != EMPTY) {\\n            cursor = treeMaximum(self, self.nodes[target].left);\\n        } else {\\n            cursor = self.nodes[target].parent;\\n            while (cursor != EMPTY && target == self.nodes[cursor].left) {\\n                target = cursor;\\n                cursor = self.nodes[cursor].parent;\\n            }\\n        }\\n    }\\n\\n    function find(Tree storage self, uint _value) public view returns (uint) {\\n        uint probe = self.root;\\n        while (probe != EMPTY) {\\n            if (_value == self.nodes[probe].value) {\\n                return probe;\\n            }\\n            if (_value < self.nodes[probe].value) {\\n                probe = self.nodes[probe].left;\\n            } else {\\n                probe = self.nodes[probe].right;\\n            }\\n        }\\n        return EMPTY;\\n    }\\n\\n    function value(Tree storage self, uint _key) public view returns (uint) {\\n        return self.nodes[_key].value;\\n    }\\n\\n    function addToCount(Tree storage self, uint _value, uint amount) internal {\\n        self.nodes[find(self, _value)].count += amount;\\n    }\\n\\n    function minusFromCount(\\n        Tree storage self,\\n        uint _value,\\n        uint amount\\n    ) internal {\\n        self.nodes[find(self, _value)].count -= amount;\\n    }\\n\\n    function insert(Tree storage self, uint _value) internal returns (uint) {\\n        uint cursor = EMPTY;\\n        uint probe = self.root;\\n        while (probe != EMPTY) {\\n            cursor = probe;\\n            if (_value < self.nodes[probe].value) {\\n                probe = self.nodes[probe].left;\\n            } else {\\n                probe = self.nodes[probe].right;\\n            }\\n        }\\n        self.counter += 1;\\n        self.nodes[self.counter] = Node({\\n            id: self.counter,\\n            value: _value,\\n            count: 1,\\n            parent: cursor,\\n            left: EMPTY,\\n            right: EMPTY,\\n            red: true\\n        });\\n        if (cursor == EMPTY) {\\n            self.root = self.counter;\\n        } else if (_value < self.nodes[cursor].value) {\\n            self.nodes[cursor].left = self.counter;\\n        } else {\\n            self.nodes[cursor].right = self.counter;\\n        }\\n        insertFixup(self, self.counter);\\n        return self.counter;\\n    }\\n\\n    function remove(Tree storage self, uint _value) internal {\\n        uint key = find(self, _value);\\n        uint probe;\\n        uint cursor; // TODO\\n        if (self.nodes[key].left == EMPTY || self.nodes[key].right == EMPTY) {\\n            cursor = key;\\n        } else {\\n            cursor = self.nodes[key].right;\\n            while (self.nodes[cursor].left != EMPTY) {\\n                cursor = self.nodes[cursor].left;\\n            }\\n        }\\n        if (self.nodes[cursor].left != EMPTY) {\\n            probe = self.nodes[cursor].left;\\n        } else {\\n            probe = self.nodes[cursor].right;\\n        }\\n        uint yParent = self.nodes[cursor].parent;\\n        self.nodes[probe].parent = yParent;\\n        if (yParent != EMPTY) {\\n            if (cursor == self.nodes[yParent].left) {\\n                self.nodes[yParent].left = probe;\\n            } else {\\n                self.nodes[yParent].right = probe;\\n            }\\n        } else {\\n            self.root = probe;\\n        }\\n        bool doFixup = !self.nodes[cursor].red;\\n        if (cursor != key) {\\n            replaceParent(self, cursor, key);\\n            self.nodes[cursor].left = self.nodes[key].left;\\n            self.nodes[self.nodes[cursor].left].parent = cursor;\\n            self.nodes[cursor].right = self.nodes[key].right;\\n            self.nodes[self.nodes[cursor].right].parent = cursor;\\n            self.nodes[cursor].red = self.nodes[key].red;\\n            (cursor, key) = (key, cursor);\\n        }\\n        if (doFixup) {\\n            removeFixup(self, probe);\\n        }\\n        delete self.nodes[cursor];\\n    }\\n\\n    function removeWithKey(Tree storage self, uint key) internal {\\n        uint probe;\\n        uint cursor; // TODO\\n        if (self.nodes[key].left == EMPTY || self.nodes[key].right == EMPTY) {\\n            cursor = key;\\n        } else {\\n            cursor = self.nodes[key].right;\\n            while (self.nodes[cursor].left != EMPTY) {\\n                cursor = self.nodes[cursor].left;\\n            }\\n        }\\n        if (self.nodes[cursor].left != EMPTY) {\\n            probe = self.nodes[cursor].left;\\n        } else {\\n            probe = self.nodes[cursor].right;\\n        }\\n        uint yParent = self.nodes[cursor].parent;\\n        self.nodes[probe].parent = yParent;\\n        if (yParent != EMPTY) {\\n            if (cursor == self.nodes[yParent].left) {\\n                self.nodes[yParent].left = probe;\\n            } else {\\n                self.nodes[yParent].right = probe;\\n            }\\n        } else {\\n            self.root = probe;\\n        }\\n        bool doFixup = !self.nodes[cursor].red;\\n        if (cursor != key) {\\n            replaceParent(self, cursor, key);\\n            self.nodes[cursor].left = self.nodes[key].left;\\n            self.nodes[self.nodes[cursor].left].parent = cursor;\\n            self.nodes[cursor].right = self.nodes[key].right;\\n            self.nodes[self.nodes[cursor].right].parent = cursor;\\n            self.nodes[cursor].red = self.nodes[key].red;\\n            (cursor, key) = (key, cursor);\\n        }\\n        if (doFixup) {\\n            removeFixup(self, probe);\\n        }\\n        delete self.nodes[cursor];\\n    }\\n\\n    function treeMinimum(\\n        Tree storage self,\\n        uint key\\n    ) private view returns (uint) {\\n        while (self.nodes[key].left != EMPTY) {\\n            key = self.nodes[key].left;\\n        }\\n        return key;\\n    }\\n\\n    function treeMaximum(\\n        Tree storage self,\\n        uint key\\n    ) private view returns (uint) {\\n        while (self.nodes[key].right != EMPTY) {\\n            key = self.nodes[key].right;\\n        }\\n        return key;\\n    }\\n\\n    function rotateLeft(Tree storage self, uint key) private {\\n        uint cursor = self.nodes[key].right;\\n        uint keyParent = self.nodes[key].parent;\\n        uint cursorLeft = self.nodes[cursor].left;\\n        self.nodes[key].right = cursorLeft;\\n        if (cursorLeft != EMPTY) {\\n            self.nodes[cursorLeft].parent = key;\\n        }\\n        self.nodes[cursor].parent = keyParent;\\n        if (keyParent == EMPTY) {\\n            self.root = cursor;\\n        } else if (key == self.nodes[keyParent].left) {\\n            self.nodes[keyParent].left = cursor;\\n        } else {\\n            self.nodes[keyParent].right = cursor;\\n        }\\n        self.nodes[cursor].left = key;\\n        self.nodes[key].parent = cursor;\\n    }\\n\\n    function rotateRight(Tree storage self, uint key) private {\\n        uint cursor = self.nodes[key].left;\\n        uint keyParent = self.nodes[key].parent;\\n        uint cursorRight = self.nodes[cursor].right;\\n        self.nodes[key].left = cursorRight;\\n        if (cursorRight != EMPTY) {\\n            self.nodes[cursorRight].parent = key;\\n        }\\n        self.nodes[cursor].parent = keyParent;\\n        if (keyParent == EMPTY) {\\n            self.root = cursor;\\n        } else if (key == self.nodes[keyParent].right) {\\n            self.nodes[keyParent].right = cursor;\\n        } else {\\n            self.nodes[keyParent].left = cursor;\\n        }\\n        self.nodes[cursor].right = key;\\n        self.nodes[key].parent = cursor;\\n    }\\n\\n    function insertFixup(Tree storage self, uint key) private {\\n        uint cursor;\\n        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\\n            uint keyParent = self.nodes[key].parent;\\n            if (keyParent == self.nodes[self.nodes[keyParent].parent].left) {\\n                cursor = self.nodes[self.nodes[keyParent].parent].right;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    key = self.nodes[keyParent].parent;\\n                } else {\\n                    if (key == self.nodes[keyParent].right) {\\n                        key = keyParent;\\n                        rotateLeft(self, key);\\n                    }\\n                    keyParent = self.nodes[key].parent;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    rotateRight(self, self.nodes[keyParent].parent);\\n                }\\n            } else {\\n                cursor = self.nodes[self.nodes[keyParent].parent].left;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    key = self.nodes[keyParent].parent;\\n                } else {\\n                    if (key == self.nodes[keyParent].left) {\\n                        key = keyParent;\\n                        rotateRight(self, key);\\n                    }\\n                    keyParent = self.nodes[key].parent;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    rotateLeft(self, self.nodes[keyParent].parent);\\n                }\\n            }\\n        }\\n        self.nodes[self.root].red = false;\\n    }\\n\\n    function replaceParent(Tree storage self, uint a, uint b) private {\\n        uint bParent = self.nodes[b].parent;\\n        self.nodes[a].parent = bParent;\\n        if (bParent == EMPTY) {\\n            self.root = a;\\n        } else {\\n            if (b == self.nodes[bParent].left) {\\n                self.nodes[bParent].left = a;\\n            } else {\\n                self.nodes[bParent].right = a;\\n            }\\n        }\\n    }\\n\\n    function removeFixup(Tree storage self, uint key) private {\\n        uint cursor;\\n        while (key != self.root && !self.nodes[key].red) {\\n            uint keyParent = self.nodes[key].parent;\\n            if (key == self.nodes[keyParent].left) {\\n                cursor = self.nodes[keyParent].right;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[keyParent].red = true;\\n                    rotateLeft(self, keyParent);\\n                    cursor = self.nodes[keyParent].right;\\n                }\\n                if (\\n                    !self.nodes[self.nodes[cursor].left].red &&\\n                    !self.nodes[self.nodes[cursor].right].red\\n                ) {\\n                    self.nodes[cursor].red = true;\\n                    key = keyParent;\\n                } else {\\n                    if (!self.nodes[self.nodes[cursor].right].red) {\\n                        self.nodes[self.nodes[cursor].left].red = false;\\n                        self.nodes[cursor].red = true;\\n                        rotateRight(self, cursor);\\n                        cursor = self.nodes[keyParent].right;\\n                    }\\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[cursor].right].red = false;\\n                    rotateLeft(self, keyParent);\\n                    key = self.root;\\n                }\\n            } else {\\n                cursor = self.nodes[keyParent].left;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[keyParent].red = true;\\n                    rotateRight(self, keyParent);\\n                    cursor = self.nodes[keyParent].left;\\n                }\\n                if (\\n                    !self.nodes[self.nodes[cursor].right].red &&\\n                    !self.nodes[self.nodes[cursor].left].red\\n                ) {\\n                    self.nodes[cursor].red = true;\\n                    key = keyParent;\\n                } else {\\n                    if (!self.nodes[self.nodes[cursor].left].red) {\\n                        self.nodes[self.nodes[cursor].right].red = false;\\n                        self.nodes[cursor].red = true;\\n                        rotateLeft(self, cursor);\\n                        cursor = self.nodes[keyParent].left;\\n                    }\\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[cursor].left].red = false;\\n                    rotateRight(self, keyParent);\\n                    key = self.root;\\n                }\\n            }\\n        }\\n        self.nodes[key].red = false;\\n    }\\n}\\n\",\"keccak256\":\"0x37e4825ff13d1868ec248d4fd3657e1074456733a82079c424ff0f2fe22f7163\",\"license\":\"MIT\"},\"src/lib/SingleRanking.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\nimport \\\"./FastArray.sol\\\";\\nimport \\\"./RankingRedBlackTree.sol\\\";\\n\\nlibrary SingleRanking {\\n    using FastArray for FastArray.Data;\\n    using RankingRedBlackTree for RankingRedBlackTree.Tree;\\n\\n    struct Data {\\n        RankingRedBlackTree.Tree tree;\\n        mapping(uint => FastArray.Data) keys;\\n        uint length;\\n    }\\n\\n    function add(Data storage _singleRanking, uint _key, uint _value) internal {\\n        FastArray.Data storage keys = _singleRanking.keys[_value];\\n\\n        if (FastArray.length(keys) == 0) {\\n            _singleRanking.tree.insert(_value);\\n        } else {\\n            _singleRanking.tree.addToCount(_value, 1);\\n        }\\n\\n        _singleRanking.keys[_value].insert(_key);\\n\\n        _singleRanking.length += 1;\\n    }\\n\\n    function remove(\\n        Data storage _singleRanking,\\n        uint _key,\\n        uint _value\\n    ) internal {\\n        FastArray.Data storage keys = _singleRanking.keys[_value];\\n\\n        if (FastArray.length(keys) > 0) {\\n            keys.remove(_key);\\n\\n            if (FastArray.length(keys) == 0) {\\n                _singleRanking.tree.remove(_value);\\n            } else {\\n                _singleRanking.tree.minusFromCount(_value, 1);\\n            }\\n        }\\n\\n        _singleRanking.length -= 1;\\n    }\\n\\n    function length(Data storage _singleRanking) public view returns (uint) {\\n        return _singleRanking.length;\\n    }\\n\\n    function get(\\n        Data storage _singleRanking,\\n        uint _offset,\\n        uint _count\\n    ) public view returns (uint[] memory) {\\n        require(_offset >= 0, \\\"Offet can not be negative\\\");\\n        require(\\n            _count >= 0 && _count <= 100,\\n            \\\"Count must be between 0 and 100\\\"\\n        );\\n\\n        uint[] memory result = new uint[](_count);\\n        uint size = 0;\\n        uint id;\\n        (id, _offset) = _singleRanking.tree.lastByOffset(_offset);\\n\\n        while (id != 0) {\\n            uint value = _singleRanking.tree.value(id);\\n            FastArray.Data storage keys = _singleRanking.keys[value];\\n\\n            if (_offset >= FastArray.length(keys)) {\\n                _offset -= FastArray.length(keys);\\n            } else if (FastArray.length(keys) < _offset + _count) {\\n                uint index = FastArray.length(keys) - 1;\\n\\n                while (index >= _offset) {\\n                    uint key = keys.get(index);\\n\\n                    result[size] = key;\\n                    size += 1;\\n\\n                    if (index == 0) {\\n                        break;\\n                    }\\n\\n                    index -= 1;\\n                }\\n\\n                _count -= FastArray.length(keys) - _offset;\\n                _offset = 0;\\n            } else {\\n                uint index = _count - 1;\\n\\n                while (index >= _offset) {\\n                    uint key = keys.get(index);\\n\\n                    result[size] = key;\\n                    size += 1;\\n\\n                    if (index == 0) {\\n                        break;\\n                    }\\n\\n                    index -= 1;\\n                }\\n                // result[size] = value;\\n                break;\\n            }\\n\\n            id = _singleRanking.tree.prev(id);\\n        }\\n\\n        return result;\\n    }\\n\\n    function getNthValue(\\n        Data storage _singleRanking,\\n        uint n\\n    ) public view returns (uint) {\\n        require(n >= 0, \\\"order can not be negative\\\");\\n        (uint256 id, ) = _singleRanking.tree.lastByOffset(n);\\n        uint value = _singleRanking.tree.value(id);\\n        return value;\\n    }\\n}\\n\",\"keccak256\":\"0x829e3a1c656abb979f5fbcbda503fb907ed68771850908a9e65fc46f32795133\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x610abd61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c80634d63fffd14610050578063b102d5fa14610079578063d7b042ca1461009c575b600080fd5b61006361005e366004610937565b6100af565b6040516100709190610963565b60405180910390f35b61008e6100873660046109a7565b6004015490565b604051908152602001610070565b61008e6100aa3660046109c0565b6107f9565b60606100bf565b60405180910390fd5b606482111561012a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f436f756e74206d757374206265206265747765656e203020616e64203130300060448201526064016100b6565b60008267ffffffffffffffff811115610145576101456109e2565b60405190808252806020026020018201604052801561016e578160200160208202803683370190505b506040517f3361f79c0000000000000000000000000000000000000000000000000000000081526004810187905260248101869052909150600090819073bb789f1A22BA24bd757D021DE2CAF43b3fb3a88190633361f79c906044016040805180830381865af41580156101e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061020a91906109f8565b965090505b80156107ee576040517f1feacfaa000000000000000000000000000000000000000000000000000000008152600481018890526024810182905260009073bb789f1A22BA24bd757D021DE2CAF43b3fb3a88190631feacfaa90604401602060405180830381865af4158015610288573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ac9190610a1c565b600081815260038a0160205260409081902090516305f739f960e21b81526004810182905291925090739FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F4906317dce7e490602401602060405180830381865af4158015610311573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103359190610a1c565b88106103c0576040516305f739f960e21b815260048101829052739FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F4906317dce7e490602401602060405180830381865af415801561038b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103af9190610a1c565b6103b99089610a4b565b9750610751565b6103ca8789610a5e565b6040516305f739f960e21b815260048101839052739FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F4906317dce7e490602401602060405180830381865af415801561041a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061043e9190610a1c565b101561064d576040516305f739f960e21b815260048101829052600090600190739FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F4906317dce7e490602401602060405180830381865af415801561049a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104be9190610a1c565b6104c89190610a4b565b90505b8881106105b7576040517fc9c3102d0000000000000000000000000000000000000000000000000000000081526004810183905260248101829052600090739FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F49063c9c3102d90604401602060405180830381865af4158015610545573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105699190610a1c565b90508087878151811061057e5761057e610a71565b6020908102919091010152610594600187610a5e565b9550816000036105a457506105b7565b6105af600183610a4b565b9150506104cb565b6040516305f739f960e21b8152600481018390528990739FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F4906317dce7e490602401602060405180830381865af4158015610609573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062d9190610a1c565b6106379190610a4b565b6106419089610a4b565b97506000985050610751565b600061065a600189610a4b565b90505b888110610749576040517fc9c3102d0000000000000000000000000000000000000000000000000000000081526004810183905260248101829052600090739FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F49063c9c3102d90604401602060405180830381865af41580156106d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106fb9190610a1c565b90508087878151811061071057610710610a71565b6020908102919091010152610726600187610a5e565b9550816000036107365750610749565b610741600183610a4b565b91505061065d565b5050506107ee565b6040517f1c727557000000000000000000000000000000000000000000000000000000008152600481018a90526024810184905273bb789f1A22BA24bd757D021DE2CAF43b3fb3a88190631c72755790604401602060405180830381865af41580156107c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e59190610a1c565b9250505061020f565b509095945050505050565b60006040517f3361f79c000000000000000000000000000000000000000000000000000000008152600481018490526024810183905260009073bb789f1A22BA24bd757D021DE2CAF43b3fb3a88190633361f79c906044016040805180830381865af415801561086d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061089191906109f8565b506040517f1feacfaa000000000000000000000000000000000000000000000000000000008152600481018690526024810182905290915060009073bb789f1A22BA24bd757D021DE2CAF43b3fb3a88190631feacfaa90604401602060405180830381865af4158015610908573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061092c9190610a1c565b925050505b92915050565b60008060006060848603121561094c57600080fd5b505081359360208301359350604090920135919050565b6020808252825182820181905260009190848201906040850190845b8181101561099b5783518352928401929184019160010161097f565b50909695505050505050565b6000602082840312156109b957600080fd5b5035919050565b600080604083850312156109d357600080fd5b50508035926020909101359150565b634e487b7160e01b600052604160045260246000fd5b60008060408385031215610a0b57600080fd5b505080516020909101519092909150565b600060208284031215610a2e57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561093157610931610a35565b8082018082111561093157610931610a35565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220e8d7db01bc586833a7071f07138d275afddb1dcb179ecf4a8771836d2311740464736f6c63430008110033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c80634d63fffd14610050578063b102d5fa14610079578063d7b042ca1461009c575b600080fd5b61006361005e366004610937565b6100af565b6040516100709190610963565b60405180910390f35b61008e6100873660046109a7565b6004015490565b604051908152602001610070565b61008e6100aa3660046109c0565b6107f9565b60606100bf565b60405180910390fd5b606482111561012a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f436f756e74206d757374206265206265747765656e203020616e64203130300060448201526064016100b6565b60008267ffffffffffffffff811115610145576101456109e2565b60405190808252806020026020018201604052801561016e578160200160208202803683370190505b506040517f3361f79c0000000000000000000000000000000000000000000000000000000081526004810187905260248101869052909150600090819073__$64be0ed8cff8e9c74167dfc40251eb2346$__90633361f79c906044016040805180830381865af41580156101e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061020a91906109f8565b965090505b80156107ee576040517f1feacfaa000000000000000000000000000000000000000000000000000000008152600481018890526024810182905260009073__$64be0ed8cff8e9c74167dfc40251eb2346$__90631feacfaa90604401602060405180830381865af4158015610288573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ac9190610a1c565b600081815260038a0160205260409081902090516305f739f960e21b8152600481018290529192509073__$f445361e8b50888b0b8cee3fd4db50a783$__906317dce7e490602401602060405180830381865af4158015610311573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103359190610a1c565b88106103c0576040516305f739f960e21b81526004810182905273__$f445361e8b50888b0b8cee3fd4db50a783$__906317dce7e490602401602060405180830381865af415801561038b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103af9190610a1c565b6103b99089610a4b565b9750610751565b6103ca8789610a5e565b6040516305f739f960e21b81526004810183905273__$f445361e8b50888b0b8cee3fd4db50a783$__906317dce7e490602401602060405180830381865af415801561041a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061043e9190610a1c565b101561064d576040516305f739f960e21b81526004810182905260009060019073__$f445361e8b50888b0b8cee3fd4db50a783$__906317dce7e490602401602060405180830381865af415801561049a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104be9190610a1c565b6104c89190610a4b565b90505b8881106105b7576040517fc9c3102d000000000000000000000000000000000000000000000000000000008152600481018390526024810182905260009073__$f445361e8b50888b0b8cee3fd4db50a783$__9063c9c3102d90604401602060405180830381865af4158015610545573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105699190610a1c565b90508087878151811061057e5761057e610a71565b6020908102919091010152610594600187610a5e565b9550816000036105a457506105b7565b6105af600183610a4b565b9150506104cb565b6040516305f739f960e21b815260048101839052899073__$f445361e8b50888b0b8cee3fd4db50a783$__906317dce7e490602401602060405180830381865af4158015610609573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062d9190610a1c565b6106379190610a4b565b6106419089610a4b565b97506000985050610751565b600061065a600189610a4b565b90505b888110610749576040517fc9c3102d000000000000000000000000000000000000000000000000000000008152600481018390526024810182905260009073__$f445361e8b50888b0b8cee3fd4db50a783$__9063c9c3102d90604401602060405180830381865af41580156106d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106fb9190610a1c565b90508087878151811061071057610710610a71565b6020908102919091010152610726600187610a5e565b9550816000036107365750610749565b610741600183610a4b565b91505061065d565b5050506107ee565b6040517f1c727557000000000000000000000000000000000000000000000000000000008152600481018a90526024810184905273__$64be0ed8cff8e9c74167dfc40251eb2346$__90631c72755790604401602060405180830381865af41580156107c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e59190610a1c565b9250505061020f565b509095945050505050565b60006040517f3361f79c000000000000000000000000000000000000000000000000000000008152600481018490526024810183905260009073__$64be0ed8cff8e9c74167dfc40251eb2346$__90633361f79c906044016040805180830381865af415801561086d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061089191906109f8565b506040517f1feacfaa000000000000000000000000000000000000000000000000000000008152600481018690526024810182905290915060009073__$64be0ed8cff8e9c74167dfc40251eb2346$__90631feacfaa90604401602060405180830381865af4158015610908573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061092c9190610a1c565b925050505b92915050565b60008060006060848603121561094c57600080fd5b505081359360208301359350604090920135919050565b6020808252825182820181905260009190848201906040850190845b8181101561099b5783518352928401929184019160010161097f565b50909695505050505050565b6000602082840312156109b957600080fd5b5035919050565b600080604083850312156109d357600080fd5b50508035926020909101359150565b634e487b7160e01b600052604160045260246000fd5b60008060408385031215610a0b57600080fd5b505080516020909101519092909150565b600060208284031215610a2e57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561093157610931610a35565b8082018082111561093157610931610a35565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220e8d7db01bc586833a7071f07138d275afddb1dcb179ecf4a8771836d2311740464736f6c63430008110033",
  "libraries": {
    "FastArray": "0x9FFEC691D21aC1Ec21BF6de9A1f310C471BeC8F4",
    "RankingRedBlackTree": "0xbb789f1A22BA24bd757D021DE2CAF43b3fb3a881"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}